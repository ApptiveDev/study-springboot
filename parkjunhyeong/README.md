# step2 스프링부트 생성과 간단한 작동원리 이해하기
먼저 해당 브랜치에 자신의 영문 디렉토리를 만들고 가장 상위의 example과 README.md 파일을 자신의 디렉토리에 copy+paste 하여 과제를 진행해주세요
## 실습 과제
아래의 설명을 따라서 적절한 버전과 dependency를 추가하여 spring initializer로 프로젝트를 생성한다.

### 스프링부트 프로젝트 생성하기

Spring Initalizer 링크 (IntelliJ 내에서 생성해도 좋다.)


https://start.spring.io/

![image](https://github.com/ApptiveDev/study-springboot/assets/81455273/e8471be4-ca23-42bc-b972-d829045de1f0)


#### 이 스터디는 아래와 같은 버전으로 진행한다.

- Spring Boot 3.1.2
- Gradle-Groovy
- Java 17

위와 같은 세팅으로 설정한다. 추후에 추가 가능하니 
스프링부트나 JDK, Java의 경우에는 여러가지 버전이 존재하고 그 사이에서 자유롭게 선택이 가능하다.

#### 차이가 뭘까?

  - 현재로서는 차이를 조사하여도 체감이 되는 부분은 없다.
  - 예로 들면 자바 17부터는 레코드를 지원하기에 이를 이용하지 않을거면 굳이 스프링부트 3.x 버전과 아직 불안정한 스프링 시큐리티 6.x를 사용할 필요가 없으니 스프링부트 2.x와 시큐리티 5.x 버전을 이용하자 라는 생각을 가질수 있다.
  - 실제로 많은 회사에서 아직 3.x로의 버전업을 진행하지 않은 이유도 시큐리티 6.x 의 불안정함 때문이라고 한다.
  - 하지만 이 스터디를 진행하는 인원들은 대부분이 처음 접하는 경우이기 때문에 3.x 버전을 사용하여 취직할 타이밍에 사용할 버전을 준비하는것이 좋을것 같다고 생각이 들어 이렇게 진행하게 되었다.

#### 추가적으로

당연히 MetaData의 Group, Artifact, Name 등은 고쳐주자

### Dependencies

- Lombok ; Entity를 선언하는데 필요한 어노테이션을 통해 자동완성을 해준다.
- Spring Web ; servlet 리스너, 파일 업로딩 IoC 초기화 등 기능과 HTTP 클라이언트와 소통(REST api)에 필요하다.
- Spring Data JPA ; 자바의 객체-관계형 데이터베이스 매핑 기술(ORM)
- Spring Security 
- Validation ; Entity를 선언시에 해당 기능으로 쉽게 객체 필드에 대한 제약조건을 설정할수 있다.
- MySQL Driver ; MySQL DB와 연결하기 위한 드라이버

  
다운로드 후 해당 레포지토리에 스터디 규칙을 지켜서 자신의 영문이름으로 폴더를 만들고 안에 압축 해제를 한다.


## 최종적으로는
#### Generate 후 적절한 JDK 설정과 docker-compose로 만들어진 docker 위의 mySQL과 연결까지 해봅시다!
이전에 example에 있는 assignment01을 실행하여 아래와 같은 결과가 나오는지 확인해봅시다.
![image](https://github.com/ApptiveDev/study-springboot/assets/81455273/f4ed7fdb-0387-423c-8bce-3f917c7b7eed)


*만약 제대로 실행이 되었지만 아래와 같은 오류가 발생한다면 일단은 괜찮습니다. step 3에서 마저 진행하도록 하겠습니다.
![image](https://github.com/ApptiveDev/study-springboot/assets/81455273/ad0d2ee4-58fa-409c-8720-c418129200ae)


## 개념 과제
- 클래스와 객체 그리고 인스턴스의 차이는 무엇인가요?
### 클래스란?
* java에서 객체를 생성하기 위한 일종의 설계도 붕어빵 틀에 비유된다
* 객체가 가지는 속성과 동작으로 이루어져 있다.

### 객체란?
* 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고, 다른 것과 식별
가능한 것을 말한다.

### 인스턴스란?
* 클래스가 붕어빵틀이라면, 그 틀을 통해 생성된 객체(붕어빵) 하나 이다.
* 클래스를 사용하여 힙 영역에 새로운 인스턴스를 생성할 수 있다.

## 생성자는 왜 사용하나요? 객체를 생성할 때 어떤 역할을 하나요?
### 생성자의 사용이유
생성자는 객체가 생성될 때 자동으로 호출되는 메서드다
setter등의 메소드를 사용하지 않아도 인스턴스의 초기화를 할 수 있다.

## 상속은 어떻게 사용되나요? 왜 중요한 개념인가요?
### 상속
상속이란 상위 클래스(부모)와 하위 클래스(자식)가 있으며, 자식 클래스는 부모 클래스를 선택해서, 그 부모의 필드, 메소드를 상속받아 그래도 쓸 수 있게 된다. <br>
상속을 하는 이유는 이미 있는 클래스를 재사용해서 만들 수 있어서 개발 시간을 줄여주기 때문에 사용한다.
### 자식클래스가 부모 클래스에서 물려 받지 못하는 경우
* 부모 클래스의 private 접근 제한을 갖는 필드 및 메소드는 자식이 물려받지 않는다
* 부모와 자식 클래스가 서로 다른 패키지에 있다면, 부모의 default접근 제한을 갖는 필드와 메소드는 자식이 물려받을 수 없다.
### 하위 클래스 생성과정
자바에서 자식 객체를 생성하면, 부모 객체를 먼저 생성한 후, 자식 객체가 그 다음 생성된다. <br>
부모의 기본 생성자 선언을 포람해서 명시적인 생성자 선언이 없으면 컴파일러가 super()를 생성한다.
여기서 super()은 부모 클래스를 나타내는 것이다. <br>
상속받고자 하는 자식 클래스명 옆에 extends 키워드를 붙이고 상속할 부모 클래스명을 적으면 된다. <br>

```
class 자식 extends 부모 {
}
```
자바는 다중 상속을 허용하지 않는다.

## 접근 제어자의 종류와 각각의 특징은 무엇인가요?
### 접근 제어
접근 제어자를 통해 변수, 메소드에 대한 접근 권한을 지정할 수 있다.
### 제한자 종류
* public : 모든 접근을 허용
* protected : 같은 패키지에 있는 객체와 상속관계의 객체들만 허용
* default : 같은 패지키에있는 객체들만 허용
* private : 현체 객체 내에서만 허용

## ORM 에 대해서 알아보세요

### ORM이란?
ORM은 Object Relational Mapping의 약자이다. <br>
Object Relational Mapping은 OOP에서 쓰이는 객체라는 개념을 구현한 클래스와 RDB에서 쓰이는 데이터인 테이블을 자동으로 매핑하는 것을 의미한다. <br>
하지만 클래스와 테이블은 서로 호환가능성을 두고 만들어 진 것이 아니기 때문에 불일치가 발생하는데, 이를 ORM을 통해 객체간의 관계를 바탕으로 SQL문을 자동으로 생성하여 불일치를 해결한다. <br>
ORM을 이용하면 SQL Query가 아닌 메소드를 사용해서 데이터를 조작할 수 있다. <br>
하지만 ORM이 모든 걸 해결해줄 수는 없다. <br>
다음과 같은 특성에서 객체-관계 간의 불일치가 발생한다. <br>
```
* 세분성 : 경우에 따라서 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 모델이 생길 수 있다.
* 상속성 : RDBMS는 객체지향 프로그래밍 언어의 특징인 상속 개념이 없다.
* 일치 : RDBMS는 기본키를 이용하여 동일성을 정의한다 그러나 자바는 객체 식별(a==b)과 객체 동일성(a.equlas(b))을 모두 정의한다. 
* 연관성 : 객체지향 언어는 방향성이 있는 객체의 참조(reference)를 사용하여 연관성을 나타내지만 RDBMS는 방향성이 없는 외래키를 이용해서 나타낸다.
* 탐색 : 자바와 RDBMS에서 객체를 접근하는 방법이 근본적으로 다르다. 자바는 그래프형태로 하나의 연결에서 다른 연결로 이동하며 탐색하지만 RDBMS는 일반적으로 SQL문을 최소화하고 JOIN을 통해 여러 엔티티를 로드하고 원하는 대상 엔티티를 선택하는 방식으로 탐색한다.

## Example을 보고 실시한다.
### example/생성자와_메서드

```
// 인스턴스 생성
Car myCar = new Car("Hyundai", "G80", 2022);
```
에서 자바의 new 키워드를 이용해 인스턴스를 생성하는 메서드를 호출한다.

그럼 자바는 Car.java로 이동하여 Car 클래스 내부의 클래스명과 같은(Car) 생성자를 이용해 인스턴스를 생성하게 된다.

#### /Car.java
  1. 만약 Car.java에서 생성자를 지우게 된다면 인스턴스는 생성되지 않게 될까요? 생성된다면 왜 생성이 되는걸까요?
   - 기본 생성자에 대해서 알아보세요
### 기본생성자
자바의 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 하지만 생성자를 정의하지 않고도 인스턴스를 생성할 수 있는데 자바 컴파일러가 기본 생성자를 기본적으로 제공해 주기 때문이다. <br>
기본생성자는 매개변수가 없다. <br>
이렇게 생성된 객체는 모든 인스턴스 변수는 초기화 되지 않은 상태이다. <br>

  2. 현재 생성자에서 speed를 0으로 따로 초기화 해주고 있는데 이를 지우게 된다면 어떻게 될까요?
지워도 0으로 변수의 기본 초기화에 따라 초기화 된다.
   ## 기본 초기화에 대해서 알아보세요
### 변수의 기본 초기화
변수의 각 타입들은 각자의 기본 값을 가지고 있다. <br>
일반적으로 정수형과 실수형은 0을 기본 값으로 가지고
문자형은 공백을 기본 값으로 가진다. <br>
boolean은 false를 가진다. <br>

   - 기본 데이터 타입과 참조 데이터 타입의 차이에 대해서 알아보세요 
### 기본 데이터 타입과 참조 데이터 타입의 차이
기본 데이터 타입은 정수, 실수 ,무자 논리 리터럴을 직접 저장하는 타입을 말한다.<br>
참조 타입은 객체의 번지를 참조하는 타입이다 배열, 열거, 클래스, 인터페이스 타입을 말한다. <br>
기본 타입은 실제 값을 변수에 저장하고 참조 타입은 메모리 주소값을 가진다. <br>
기본 타입은 스택 영역에 참조 타입은 힙 영역에 생성된다. <br>

  3. 반대로 생성자를 여러개 생성하는 생성자 오버로딩에 대해서 알아보세요
### 생성자 오버로딩
매개 변수를 다르게 하여 생성자를 여러개 선언할 수 있다. <br>
인스턴스를 생성할 때 매개 변수에 맞는 생성자가 호출된다. <br>

   - 생성자 오버로딩시 주의해야할 점에 대해서 알아보세요 
### 생성자 오버로딩시 주의할 점	
	생성자가 하나 이상있으면 기본 생성자는 제공되지 않아서 주의해야 한다. <br>
	매개 변수의 타입과 개수 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아	니다. <br>

  4. 만약 두 생성자가 매개변수의 개수와 형식이 동일하다면 어떤 오류가 발생할까요? (직접 코드를 작성해보면 좋습니다.)
### 생성자가 매개변수의 개수와 형식이 동일하다면 

` error: constructor Car(String,String,int) is already defined in class Car `
이미 생성자가 정의 되어있다고 에러가 뜬다. <br>
  5. *혹시 가능하다면 생성자 오버로딩을 구현해봅시다!
        ``` 
        // 기본 생성자
            public Car() {
                // TODO: 필드를 기본값으로 초기화
            }

            // 매개변수가 3개인 생성자
            public Car(String make, String model, int year) {
                // TODO: make, model, year 초기화, speed는 기본값으로 초기화
            }

            // 매개변수가 4개인 생성자
            public Car(String make, String model, int year, int speed) {
                // TODO: 모든 필드 초기화   
            }
        ```

#### /Main.java
  1. 기존에 만든 mycar 인스턴스 대신에 새로운 자동차를 만들어주고 그 자동차의 속도를 100으로 설정해주는 코드를 작성해주세요
  2. 생성자 오버로딩을 구현해보았다면 초기 속도가 100인 자동차의 인스턴스를 만들어보고 emergencyBrake라는 메서드를 만들어 한번에 속도를 0으로 줄이는 메서드를 적용시켜봅시다.
     ![image](https://github.com/ApptiveDev/study-springboot/assets/81455273/b57033d1-8d94-467f-9277-703050aa64bc)

### example/
- 왜 OOP에서는 인스턴스를 만들어 사용할까?
## OOP에서 인스턴스를 만들어서 사용하는 이유

**모듈화와 추상화** : OOP는 프로그램을 더 작은 모듈로 나누는 것을 용이하게 하며, 이를 통해 복잡한 문제를 더 작은 문제로 분해할 수 있다. 클래스를 정의하고 인스턴스를 생성함으로써 이러한 모듈화와 추상화를 달성할 수 있다. <br>

**상태 및 동작의 캡슐화** : 객체는 상태(속성)와 동작(메소드)를 함께 캡슐화하며, 이로써 관련된 정보와 동작을 논리적으로 그룹화할 수 있다 이는 코드의 가독성을 높이고 개발자가 객체의 내부 구현을 숨길 수 있도록 도와준다 <br>
**다형성과 확장성** : 다형성을 통해 인터페이스를 통일하고, 다양한 클래스의 인스턴스들을 동일한 방식으로 다룰 수 있다 또한 상속과 인터페이스 구현을 통해 기존 클래스를 확장하여 새로운 기능을 추가할 수 있다. <br>
**효율적인 자원관리**: 인스턴스는 필요한 시점에 생성 및 소멸된다 이로써 메모리 공간을 효육적으로 관리할 수 있다. <br>
**협업과 유지보수** : 여러 개발자가 동시에 작업할 때 클래스와 인스턴스를 사용하여 작업을 분리하고 조율할 수 있다. <br>


- private 멤버에 대한 public 접근자 메서드를 왜 따로 만들어줄까?
### private 멤버에 대한 public 접근자 메소드를 따로 만드는 이유는캡슐화와 정보 은닉을 지원하기 위해서 이다. <br>
**정보은닉** : private 멤버는 외부에서 직접 접근할 수 없기 때문에, 객체의 내부 구현과 상세한 동작이 외부에 노출되지 않는다 이로써 객체의 내부 구조를 변경하거나 업데이트할 때 외부 코드에 영향을 최소화할 수 있다. <br>
**캡슐화** : 객체의 내부 상태와 동작을 외부로부터 보호하고, 필요한 기능만을 노출시켜 코드의 안정성과 유지보수성을 높인다. <br>

  - private 멤버 변수에 직접 접근할 수 없을 때, 어떻게 값을 읽고 변경할 수 있게될까?
private 멤버 변수에 직접 접근할 수 없을 때 public 접근자(getter)와 설정자(setter)메소드를 사용한다. 이러한 접근자와 설정자는 메서드 캡슐화와 정보 은닉을 지원하는 중요한 역할을 한다.
